# -*- coding: utf-8 -*-
"""DL4CV_Weekly_Assignment_3_Solution.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1t66COrkBMFBQtUhPIveLoeZPA_X_uBhm
"""

# Imports
import cv2
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
from sklearn.cluster import KMeans
from sklearn.neighbors import NearestNeighbors
import glob
import math
from numpy.lib.shape_base import split
# %matplotlib inline uncomment this line if you're running this notebook on your local PC

"""### Question 1: Affine transformations

Apply the following chain of transformations on the generated coordinates:

1. Rotation by 30 degrees.
2. Translation of x coordinate by -1 units and y coordinate by 1 units.
3. Scaling by 2 units.
4. Rotation by 30 degrees.


![options.png](data:image/png;base64,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)
The following figure represents 5 different set of points(each in different color) plotted on a cartesian plane. \\
One of them is the correct output that will be produced when we apply the transformations mentioned above to the given input. \\
Which of the following is the correct output which is produced after applying these transformations?

1. A
2. B
3. C
4. D
"""

# DO NOT CHANGE THIS CODE
np.random.seed(10)

#defining two functions to build a grid and display it in a plot
def get_grid(x, y, homogenous=False):
    coords = np.indices((x, y)).reshape(2, -1)
    # coords[0,2] = 2
    # coords[1,1] = 2
    # coords[0,3] = 2
    # coords[1,3] = 2
    return np.vstack((coords, np.ones(coords.shape[1]))).astype(int) if homogenous else coords

def grid_plotter(points, labels):
    markers = ['o', 'x', 's', '^', 'p', 'v']
    fig, ax = plt.subplots(figsize=(8,6))
    for i, p in enumerate(points):
        x, y = p[0], p[1]
        ax.scatter(x, y, label=labels[i], marker=markers[i], alpha=0.8, s=100)
    ax.legend(loc='lower right')
    ax.set_xlim(-5, 5)
    ax.set_ylim(-5, 5)

    ax.grid(True)
    plt.show()

#function to display the plotted graph
def show_image(image):
    fig, ax = plt.subplots(figsize=(8,6))
    ax.imshow(image)
    plt.show()

#generated coordinates
coords = get_grid(2, 2, homogenous=True)

# Get sample coordinates
# The output of the grid plotter shows how the sample points are scattered in the cartesian plane
grid_plotter(np.array([coords]),
             labels=['original'])

# Defining a function to rotate the given set of points
def get_rotation(angle):
    '''
    Input arguments:
    - angle : The angle with which the points should be rotated

    Outputs:
    - rotation matrix : A rotation matrix (numpy array) with the given input angle

    '''
    ### YOUR CODE STARTS HERE

    #convert the angle input to radians

    # construct a rotation matrix with the given angle in the form of a numpy array and return it
    # Hint: recall lecture 1 of week 3 to construct the matrix

    ### YOUR CODE ENDS HERE
    angle = np.radians(angle)

    # construct a rotation matrix with the given angle in the form of a numpy array and return it
    # Hint: recall lecture 1 of week 3 to construct the matrix
    return np.array([
        [np.cos(angle), -np.sin(angle), 0],
        [np.sin(angle),  np.cos(angle), 0],
        [0, 0, 1]
    ])

# Defining a function to translate the given set of points
def get_translation(tx, ty):
    '''
    Input arguments:
    - tx, ty : Units by which the x and y coordinates should be translated

    Outputs:
    - translation matrix : A translation matrix (numpy array) with the given inputs

    '''

    ### YOUR CODE STARTS HERE

    # construct a translation matrix with the given input units in the form of a numpy array and return it
    # Hint: recall lecture 1 of week 3 to construct the matrix


    ### YOUR CODE ENDS HERE
    return np.array([
        [1, 0, tx],
        [0, 1, ty],
        [0, 0, 1]
    ])

def get_scale(s):
    '''
    Input arguments:
    - s : Amount by which the coordinates should be scaled by

    Outputs:
    - scaling matrix : A scaling matrix (numpy array) with the given inputs

    '''

    ### YOUR CODE STARTS HERE

    # construct a scaling matrix with the given input units in the form of a numpy array and return it
    # Hint: recall lecture 1 of week 3 to construct the matrix

    ### YOUR CODE ENDS HERE

    return np.array([
        [s, 0, 0],
        [0, s, 0],
        [0, 0, 1]
    ])

# Creating sample rotation, translation and scaling matrices
R1 = get_rotation(30)
T1 = get_translation(-1, 1)
S1 = get_scale(2)

### YOUR CODE STARTS HERE

# Apply the following transformation
# Rotation -> Translation -> Scaling -> Rotation"
coords1 = R1 @ T1 @ S1@ R1@coords

### YOUR CODE ENDS HERE

coords1 = R1 @ T1 @ S1@ R1@coords
##code to generate the plot given in the image

grid_plotter(np.array([coords1]),
             labels=['A'])

"""### Question 2: Distance between 2 transformed points
Apply the transformations as mentioned in the comments of the next code block to coords and calculate the mean of the euclidean distances between the points.

What is the floor value of the mean?

1. 1
2. 5
3. 2
4. 0

"""

### YOUR CODE STARTS HERE

#apply the following chain of transformations R1 -> S1 -> T1 to coords and name it coords_1
coords_1 = R1 @ S1 @ T1 @ coords

#apply the following chain of transformations T1 -> R1 -> S1-> T1 to coords and name it coords_2
coords_2 = T1 @ R1@S1@ T1 @ coords

#split them to individual points, there are 4 different points in the form of (xi, yi, zi) in each of the
#transformed coordinates as calculated above
split_1 = np.split(coords_1, coords_1.shape[1], axis=1)
split_2 = np.split(coords_2, coords_2.shape[1], axis=1)

#calculate the euclidean distances between each of those points in coords_1 and coords_2
# Hint: distance is d(point1 of coords_1, point1_coords2)
# Take the mean of the distances and at last take the floor of the value and mark your answer

#calculating the euclidean distances in a pair wise fashion
dist = []
for i in range(0, len(split_1)):
  dist.append(np.linalg.norm(split_1[i] - split_2[i]))

#calculating the mean and taking the floor value of it
mean_value = np.mean(np.array(dist))
np.floor(mean_value)



### YOUR CODE ENDS HERE

"""### Question 3: Bag of visual words (BOVW)

Follow the below mentioned steps:\
Step 1. Given a folder of images, use SIFT to extract their feature descriptors.\
Step 2. Perform k-means clustering on the extracted descriptors.\
Step 3. Create histograms by taking help of the clusters calculated in the previous step.\
Step 4. Estimate 5 nearest neighbours to a given image and add the distances of those 5 neighbours.


What is the range of the sum as calculated in step 4?

1. 0 - 200
2. 200 - 400
3. 400 - 600
4. 600 - 800
"""

# defining a feature extractor that we want to use
# in this case, we will use SIFT
extractor = cv2.xfeatures2d.SIFT_create()

# defining a function to extract the keypoints and descriptors for a given image
def features(image, extractor):
    keypoints, descriptors = extractor.detectAndCompute(image, None)
    return keypoints, descriptors

# implementing a histogram building function which takens in the clustering algorithm
# and returns a histogram
def build_histogram(descriptor, cluster_alg):

    # defining a place holder for the histogram, with the number of bins being
    # equal to the number of cluster centres
    histogram = np.zeros(len(cluster_alg.cluster_centers_))
    cluster_result =  cluster_alg.predict(descriptor)

    ### YOUR CODE STARTS HERE

    # for all the centres that are returned in the above line,
    # increase their bin value by 1 in the histogram array
    for i in cluster_result:
        histogram[i] += 1.0

    ### YOUR CODE ENDS HERE

    return histogram

def extract_descriptors(images, extractor):
    #iterate over the list of images and extract descriptors
    descriptor_list = []
    for image in images:

        ### YOUR CODE STARTS HERE
        # pass the image and the extractor to the features function
        # defined in the above lines
        keypoint, descriptor = features(image, extractor)

        # append the descriptors to the descriptor_list
        descriptor_list.append(descriptor)

    # vertically stack all the elements of the list
    # using np.vstack()
    descriptors=descriptor_list[0]

    for descriptor in descriptor_list[1:]:
        descriptors=np.vstack((descriptors,descriptor))

        ### YOUR CODE ENDS HERE

    descriptors_float = descriptors.astype(float)

    return descriptors_float

"""Upload the assignment3_content.zip file provided to colab and run the cell below to extract the data files required for next question"""

!unzip assignment3_content.zip

### YOUR CODE STARTS HERE

#read all the images present in the sample images folder
# and store them in an array
#hint: read them using cv2.imread()
filenames = [img for img in glob.glob("assignment3_content/sample_images/*.jpg")]
#filenames = [img for img in glob.glob("sample_images/*.jpg")]

print
images = []
for img in filenames:
    n= cv2.imread(img)
    # n = cv2.cvtColor(n, cv2.COLOR_BGR2GRAY)
    images.append(n)

### YOUR CODE ENDS HERE

# extract all the descriptors using the extract_descriptors function
descriptors_float = extract_descriptors(images, extractor)

#use the kmeans clustering algorithm and cluster
#the descriptors extracted in the above line
kmeans = KMeans(n_clusters = 100, random_state=0)
kmeans.fit(descriptors_float)


histograms_images = []

### YOUR CODE STARTS HERE

# iterate over the images list and calculate
# the histograms of the images and append to the
# histograms_images list
for image in images:
    keypoint, descriptor = features(image, extractor)
    descriptor = descriptor.astype(float)

    if (descriptor is not None):
        histogram = build_histogram(descriptor, kmeans)

        histograms_images.append(histogram)

### YOUR CODE ENDS HERE

# using the nearest neighbors algorithm
neighbor = NearestNeighbors(n_neighbors = 5)
neighbor.fit(histograms_images)


data = cv2.imread('assignment3_content/White_Pelican_0072_96975.jpg')
# data = cv2.imread('White_Pelican_0072_96975.jpg')


# pass the data to the features function and
# build the histogram for it using the build_histogram
# function
keypoint, descriptor = features(data, extractor)
descriptor = descriptor.astype(float)
histogram = build_histogram(descriptor, kmeans)

# estimate the 5 nearest neighbors and get their distances
dist, result = neighbor.kneighbors([histogram])

### YOUR CODE STARTS HERE
# sum the values in the dist array
# mark the answer for the question 2 using the output
np.sum(dist)

### YOUR CODE ENDS HERE

"""If you observe closely, the test image is a pelican but the nearest neighbors are not pelicans. Our method does not correctly identify the neighbors. This is the drawback of Bag of Visual Words. All the local features are encoded into a single code vector ignoring the position of the feature descriptors. This results in the loss of spatial information between words in the final code vector. Thus, to incorporate the spatial information into the final code vector, we can apply Spatial Pyramid Matching."""

